import 'dotenv/config';
import { createAgent, startOrchestrator, type AgentContext } from '@aethermind/sdk';

const researcher = createAgent({
  name: 'researcher',
  model: 'gpt-4',
  systemPrompt: 'You are a research assistant that gathers information on topics.',
  temperature: 0.7,
  maxRetries: 3,
  timeout: 60000,
  logic: async (ctx: AgentContext) => {
    ctx.logger.info('Starting research task');
    
    const input = ctx.input as { topic?: string };
    const topic = input?.topic || 'AI Agents';
    
    ctx.logger.info(`Researching topic: ${topic}`);
    
    await new Promise((resolve) => setTimeout(resolve, 1000));
    
    const result = {
      topic,
      findings: [
        'AI agents are autonomous systems that can perceive and act in their environment',
        'Multi-agent systems enable collaboration between specialized AI agents',
        'Agent orchestration is key to building complex AI workflows',
      ],
      timestamp: new Date().toISOString(),
    };
    
    ctx.logger.info('Research completed', { findingsCount: result.findings.length });
    return result;
  },
});

const analyst = createAgent({
  name: 'analyst',
  model: 'gpt-4',
  systemPrompt: 'You are an analyst that processes and summarizes research findings.',
  temperature: 0.5,
  logic: async (ctx: AgentContext) => {
    ctx.logger.info('Starting analysis task');
    
    const input = ctx.input as { initial?: unknown; previousSteps?: Record<string, unknown> };
    const researchOutput = input?.previousSteps?.['research'] as { findings?: string[] } | undefined;
    
    if (!researchOutput?.findings) {
      ctx.logger.warn('No research findings to analyze');
      return { summary: 'No data available', confidence: 0 };
    }
    
    ctx.logger.info(`Analyzing ${researchOutput.findings.length} findings`);
    
    await new Promise((resolve) => setTimeout(resolve, 500));
    
    const result = {
      summary: `Analyzed ${researchOutput.findings.length} key findings about AI agents and their orchestration capabilities.`,
      keyInsights: ['Autonomous operation', 'Multi-agent collaboration', 'Workflow orchestration'],
      confidence: 0.85,
    };
    
    ctx.logger.info('Analysis completed', { confidence: result.confidence });
    return result;
  },
});

const writer = createAgent({
  name: 'writer',
  model: 'gpt-4',
  systemPrompt: 'You are a technical writer that creates clear, concise reports.',
  temperature: 0.8,
  logic: async (ctx: AgentContext) => {
    ctx.logger.info('Starting writing task');
    
    const input = ctx.input as { initial?: unknown; previousSteps?: Record<string, unknown> };
    const analysisOutput = input?.previousSteps?.['analyze'] as { summary?: string; keyInsights?: string[] } | undefined;
    
    if (!analysisOutput) {
      ctx.logger.warn('No analysis to write about');
      return { report: 'No analysis available', wordCount: 0 };
    }
    
    ctx.logger.info('Generating report');
    
    await new Promise((resolve) => setTimeout(resolve, 500));
    
    const report = `
# AI Agents Research Report

## Summary
${analysisOutput.summary}

## Key Insights
${analysisOutput.keyInsights?.map((insight) => `- ${insight}`).join('\n')}

## Conclusion
AI agent orchestration platforms like Aethermind AgentOS provide the infrastructure needed to build, deploy, and manage multi-agent AI systems effectively.

---
Generated by Aethermind AgentOS
    `.trim();
    
    const result = {
      report,
      wordCount: report.split(/\s+/).length,
      generatedAt: new Date().toISOString(),
    };
    
    ctx.logger.info('Report generated', { wordCount: result.wordCount });
    return result;
  },
});

async function main() {
  console.log('Starting Aethermind AgentOS Example\n');
  
  const orchestrator = startOrchestrator({
    agents: [researcher, analyst, writer],
    config: {
      maxConcurrentAgents: 5,
      enableTracing: true,
      enableCostTracking: true,
    },
    provider: process.env['OPENAI_API_KEY']
      ? { type: 'openai', apiKey: process.env['OPENAI_API_KEY'] }
      : undefined,
    onLog: (entry) => {
      const level = entry.level.toUpperCase().padEnd(5);
      const agent = entry.agentId ? `[${entry.agentId.slice(0, 8)}]` : '';
      console.log(`${level} ${agent} ${entry.message}`);
    },
  });

  orchestrator.workflowEngine.registerWorkflow({
    name: 'research_pipeline',
    description: 'Research, analyze, and report on a topic',
    entryPoint: 'research',
    steps: [
      { id: 'research', agent: 'researcher', next: 'analyze' },
      { id: 'analyze', agent: 'analyst', next: 'write', condition: 'research.success' },
      { id: 'write', agent: 'writer' },
    ],
  });

  console.log('Executing single agent task...\n');
  const singleResult = await orchestrator.executeTask('researcher', { topic: 'AI Agent Orchestration' });
  console.log('\nSingle agent result:', JSON.stringify(singleResult.output, null, 2));

  console.log('\n\nExecuting workflow pipeline...\n');
  try {
    const workflowResult = await orchestrator.executeWorkflow('research_pipeline', { topic: 'Multi-Agent Systems' });
    
    const lastStepKey = Array.from(workflowResult.results.keys()).pop();
    const finalOutput = lastStepKey ? workflowResult.results.get(lastStepKey)?.output : null;
    
    console.log('\nWorkflow completed!');
    console.log('Execution ID:', workflowResult.executionId);
    console.log('\nFinal Report:');
    console.log((finalOutput as { report?: string })?.report || 'No report generated');
  } catch (error) {
    console.error('Workflow failed:', (error as Error).message);
  }

  console.log('\n\nExample completed. Shutting down...');
  await orchestrator.shutdown();
}

main().catch(console.error);
